<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>php on Yecoder</title>
    <link>https://yecoder.com/tags/php/</link>
    <description>Recent content in php on Yecoder</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 12 Jul 2022 13:28:00 +0000</lastBuildDate><atom:link href="https://yecoder.com/tags/php/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Run PHPUnit tests, multiple times with different data sets</title>
      <link>https://yecoder.com/posts/run-phpunit-tests-multiple-times-with-different-data-sets/</link>
      <pubDate>Tue, 12 Jul 2022 13:28:00 +0000</pubDate>
      
      <guid>https://yecoder.com/posts/run-phpunit-tests-multiple-times-with-different-data-sets/</guid>
      <description>So most of you might know this, Specially you old-school PHP developers ðŸ™‚ but itâ€™s not gonna fill the internetâ€™s capacity so let me be happy by writing this post.
You might have seen some PHPUnit tests with arguments! Have you asked yourself how itâ€™s possible and who sends those arguments to these tests? The answer is simple! Data Providers
With PHPUnit, you can define arguments for your test function, and in the DocBlock you mention that there is a data provider for this function, and inside that function just provide the data ðŸ™‚</description>
    </item>
    
    <item>
      <title>Laravel Custom Helpers, Facades, and Testing Fakes</title>
      <link>https://yecoder.com/posts/laravel-custom-helpers-facades-and-testing-fakes/</link>
      <pubDate>Fri, 18 Feb 2022 11:56:00 +0000</pubDate>
      
      <guid>https://yecoder.com/posts/laravel-custom-helpers-facades-and-testing-fakes/</guid>
      <description>Letâ€™s consider that we want to create a custom helper named SSH. This helper is going to connect to a remote server via ssh and execute some commands.
Commands Since we might have many commands, I would create an interface first.
// app/Commands/Command.php namespace App\SSHCommands; use App\Contracts\SSHCommand; interface Command { public function content(); } And then an example command.
// app/Commands/DirectoryListCommand.php namespace App\SSHCommands; use App\Contracts\SSHCommand; class DirectoryListCommand implements Command { public function content() { return &amp;#34;ls -la&amp;#34;; } } Helper Alright.</description>
    </item>
    
  </channel>
</rss>
